// backend/src/routes/accessRoutes.js
const express = require("express");
const jwt = require("jsonwebtoken");
const { verifyTelegramInitData, signInitData } = require("../utils/telegram");

const router = express.Router();

/**
 * POST /tg  (монтируется на /open, итоговый путь: /open/tg)
 * Body: { initData: string, token?: string }
 */
router.post("/tg", async (req, res) => {
  try {
    const { initData, token: linkToken } = req.body || {};
    const maxAge = Number(process.env.TG_INITDATA_MAX_AGE || 86400);
    const botToken = process.env.BOT_TOKEN;
    const jwtSecret = process.env.JWT_SECRET;

    const vr = verifyTelegramInitData(initData, botToken, maxAge);
    if (!vr.ok) {
      return res.status(401).json({ ok: false, error: vr.reason });
    }

    const tgUser = vr.user || null;

    const accessToken = jwt.sign(
      {
        sub: tgUser ? `tg:${tgUser.id}` : undefined,
        typ: "client",
        tg: tgUser
          ? {
              id: tgUser.id,
              username: tgUser.username,
              first_name: tgUser.first_name,
              last_name: tgUser.last_name,
              language_code: tgUser.language_code,
              is_premium: tgUser.is_premium,
            }
          : null,
        linkToken: linkToken || null,
      },
      jwtSecret,
      { expiresIn: "15m" }
    );

    return res.json({ ok: true, accessToken, expiresIn: 900, tgUser });
  } catch (err) {
    console.error("POST /tg error:", err);
    return res.status(500).json({ ok: false, error: "INTERNAL" });
  }
});

/**
 * DEV ONLY: GET /tg/dev-initdata  (итог: /open/tg/dev-initdata)
 */
if (process.env.NODE_ENV !== "production") {
  router.get("/tg/dev-initdata", (req, res) => {
    const botToken = process.env.BOT_TOKEN;
    if (!botToken) return res.status(400).json({ ok: false, error: "NO_BOT_TOKEN" });

    const now = Math.floor(Date.now() / 1000);
    const user = {
      id: Number(req.query.user_id || 11111111),
      username: req.query.username || "demo_user",
      first_name: req.query.first_name || "Demo",
      last_name: req.query.last_name || "",
      language_code: "en",
      is_premium: false,
    };

    const fields = {
      auth_date: String(now),
      query_id: req.query.query_id || "AAH_test_query_id",
      user,
    };

    const initData = signInitData(fields, botToken);
    return res.json({ ok: true, initData, note: "Use this initData in POST /open/tg for local testing" });
  });
}

module.exports = router;
/* ===== Client Session routes ===== */
const requireClientAuth = require("../middleware/requireClientAuth");
const { startSession, refreshAccess } = require("../services/sessionService");

/**
 * POST /session/start  (итог: /open/session/start)
 * Требует заголовок Authorization: Bearer <access>
 * озвращает новый refresh и access (ротация токенов при старте viewer)
 */
router.post("/session/start", requireClientAuth, async (req, res) => {
  try {
    const { refreshToken, accessToken } = await startSession({ req, client: req.client });
    return res.json({ ok: true, refreshToken, accessToken });
  } catch (e) {
    console.error("POST /session/start error:", e);
    res.status(500).json({ ok: false, error: "INTERNAL" });
  }
});

/**
 * POST /session/refresh  (итог: /open/session/refresh)
 * Body: { refreshToken }
 * озвращает новый access
 */
router.post("/session/refresh", async (req, res) => {
  try {
    const { refreshToken } = req.body || {};
    const out = await refreshAccess({ refreshToken });
    if (!out.ok) return res.status(401).json({ ok: false, error: out.error });
    return res.json({ ok: true, accessToken: out.accessToken });
  } catch (e) {
    console.error("POST /session/refresh error:", e);
    res.status(500).json({ ok: false, error: "INTERNAL" });
  }
});
